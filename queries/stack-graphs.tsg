; ####
; Rust
; ####
;
; All nodes that can contain uses must have:
;
;     .scope - The value namespace of the lexical scope in which the
;         syntax-node appears--that is, the *enclosing* lexical scope. This
;         namespace is used for looking up functions, local variables,
;         arguments, consts, statics, and constructors.
;
;     .types - The type namespace of the current lexical scope, used for
;         looking up types, modules, and crates.
;
; Rust has separate value and type namespaces. That is, every lexical scope
; can contain both value bindings and type bindings, and they're distinct,
; as though the things in the type namespace (types, modules, crates) always
; had names that started with a special invisible sigil.
;
; For now we represent the type namespace as a separate node.
;
; The identifier syntax-node of an item's name or a binding name in a pattern
; has:
;
;     .def - The node that pops the item's name.

attribute node_reference = node         => type = "push_symbol", symbol = (source-text node), is_reference, source_node = node
attribute node_symbol = node            => symbol = (source-text node), source_node = node
attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol

;; Root scopes.
[
  (source_file) @root
  (mod_item body: (declaration_list) @root)
] {
  node @root.scope
  node @root.types
}

;; Create the inner scope for expressions that introduce local bindings
;; using patterns.
[
  (for_expression pattern: (_) @pat) @parent
  (if_let_expression pattern: (_) @pat) @parent
  (match_arm pattern: (_) @pat) @parent
  (while_let_expression pattern: (_) @pat) @parent
] {
  node @parent.inner_scope
  edge @parent.inner_scope -> @pat.defs
  attr (@parent.inner_scope -> @pat.defs) precedence = 1
  edge @parent.inner_scope -> @parent.scope
}

;; Link children to parents.
[
  (for_expression body: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (if_let_expression consequence: (_) @child) @parent
  (match_arm pattern: (match_pattern condition: (_) @child)) @parent
  (match_arm value: (_) @child) @parent
  (while_let_expression body: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
  let @child.types = @parent.types
}

;; Create the "definitions" node for each pattern. This query matches only the
;; outermost node of each pattern.
[
  (for_expression pattern: (_) @pat)
  (if_let_expression pattern: (_) @pat)
  (match_arm pattern: (_) @pat)
  (while_let_expression pattern: (_) @pat)
  (let_declaration pattern: (_) @pat)
  (parameter pattern: (_) @pat)
  (closure_parameters (_) @pat)
] {
  node @pat.defs
}

;; Subpatterns inherit the parent's defs node.
[
  (match_pattern (_) @pat (_)*) @parent
  (tuple_pattern (_) @pat) @parent
  (slice_pattern (_) @pat) @parent
  (field_pattern name: (shorthand_field_identifier) @pat) @parent
  (field_pattern pattern: (_) @pat) @parent
  (mut_pattern (mutable_specifier) (_) @pat) @parent
  (ref_pattern (_) @pat) @parent
  (captured_pattern (identifier) @pat "@" (_)) @parent
  (captured_pattern (identifier) "@" (_) @pat) @parent
  (reference_pattern "&" (mutable_specifier)? (_) @pat) @parent
  (or_pattern (_) @pat) @parent
] {
  let @pat.defs = @parent.defs
}

;; Tuple-struct subpatterns inherit the parent's defs node.
[
  (tuple_struct_pattern type: (_) (_)* @pats) @parent
] {
  for pat in @pats {
    let pat.defs = @parent.defs
  }
}

;; Identifier-patterns are definitions.
[
  (for_expression pattern: (identifier) @ident)
  (if_let_expression pattern: (identifier) @ident)
  (while_let_expression pattern: (identifier) @ident)
  (let_declaration pattern: (identifier) @ident)
  (parameter pattern: (identifier) @ident)
  (closure_parameters (identifier) @ident)
  (match_pattern (identifier) @ident (_)*)
  (tuple_pattern (identifier) @ident)
  (slice_pattern (identifier) @ident)
  (field_pattern name: (shorthand_field_identifier) @pat)
  (field_pattern pattern: (identifier) @ident)
  (mut_pattern (mutable_specifier) (identifier) @ident)
  (ref_pattern (identifier) @ident)
  (captured_pattern (identifier) @ident "@" (_))
  (reference_pattern "&" (mutable_specifier)? (identifier) @ident)
  (or_pattern (identifier) @ident)
] {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @ident.defs -> @ident.def
}

;; Identifier sub-patterns of tuple-struct patterns are definitions.
;; But I don't see how to make this pattern work. The subpatterns
;; need to be a named field.
;; [
;;   (tuple_struct_pattern type: (_) (_)* (identifier) @ident (_)*) @parent
;; ] {
;;   node @ident.def
;;   attr (@ident.def) node_definition = @ident
;;   edge @ident.defs -> @ident.def
;; }

;; Items that have a `type_parameters` child have an `.inner_types` node
;; that is the type namespace presented to their children.
;;
;; Items that could have type parameters, but in fact don't, also need a
;; `.inner_types` node, but it's just the same node as the enclosing type
;; namespace.
[
  (associated_type type_parameters: (type_parameters)? @params) @parent
  (enum_item type_parameters: (type_parameters)? @params) @parent
  (function_item type_parameters: (type_parameters)? @params) @parent
  (function_signature_item type_parameters: (type_parameters)? @params) @parent
  (impl_item type_parameters: (type_parameters)? @params) @parent
  (struct_item type_parameters: (type_parameters)? @params) @parent
  (trait_item type_parameters: (type_parameters)? @params) @parent
  (type_item type_parameters: (type_parameters)? @params) @parent
  (union_item type_parameters: (type_parameters)? @params) @parent
  (function_type (for_lifetimes)? @params) @parent
] {
  if some @params {
    node @parent.inner_types
    node @params.type_param_defs
    edge @parent.inner_types -> @params.type_param_defs
    attr (@parent.inner_types -> @params.type_param_defs) precedence = 1
    edge @parent.inner_types -> @parent.types

    node @parent.inner_values
    node @params.const_param_defs
    edge @parent.inner_values -> @params.const_param_defs
    attr (@parent.inner_values -> @params.const_param_defs) precedence = 1
    edge @parent.inner_values -> @parent.scope
  } else {
    let @parent.inner_types = @parent.types
    let @parent.inner_values = @parent.scope
  }
}

[
  (type_parameters (lifetime) @lifetime) @params
  (for_lifetimes (lifetime) @lifetime) @params
] {
  node @lifetime.def
  attr (@lifetime.def) node_definition = @lifetime
  edge @params.type_param_defs -> @lifetime.def
}

(type_parameters (type_identifier) @ident) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.type_param_defs -> @ident.def
}

(type_parameters (const_parameter name: (_) @ident)) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.const_param_defs -> @ident.def
}

;; Direct children of generics get the inner scope.
;;
;; This lists all contexts in most items, except the name.
;; and all contexts within a function except the name and the body;
;; the body is special because it also sees the function parameter bindings.
[
  (associated_type type_parameters: (_) @child) @parent
  (associated_type bounds: (_) @child) @parent
  (enum_item type_parameters: (_) @child) @parent
  (enum_item (where_clause) @child) @parent
  (enum_item body: (_) @child) @parent
  (function_item type_parameters: (_) @child) @parent
  (function_item parameters: (_) @child) @parent
  (function_item return_type: (_) @child) @parent
  (function_item (where_clause) @child) @parent
  (function_signature_item (_) @child) @parent
  (impl_item type_parameters: (_) @child) @parent
  (impl_item trait: (_) @child) @parent
  (impl_item type: (_) @child) @parent
  (impl_item (where_clause) @child) @parent
  (impl_item body: (_) @child) @parent
  (struct_item type_parameters: (_) @child) @parent
  (struct_item (where_clause) @child) @parent
  (struct_item body: (_) @child) @parent
  (trait_item type_parameters: (_) @child) @parent
  (trait_item bounds: (_) @child) @parent
  (trait_item (where_clause) @child) @parent
  (trait_item body: (_) @child) @parent
  (type_item type_parameters: (_) @child) @parent
  (type_item type: (_) @child) @parent
  (union_item type_parameters: (_) @child) @parent
  (union_item body: (_) @child) @parent

  (function_type trait: (_) @child) @parent  ;; only for Fn, FnMut, FnOnce
  (function_type parameters: (_) @child) @parent
  (function_type return_type: (_) @child) @parent
] {
  let @child.scope = @parent.inner_values
  let @child.types = @parent.inner_types
}

[
  (function_item parameters: (_) @parameters body: (_) @body) @parent
  (closure_expression parameters: (_) @parameters body: (_) @body) @parent
] {
  node @body.scope
  edge @body.scope -> @parameters.defs
  attr (@body.scope -> @parameters.defs) precedence = 1
  edge @body.scope -> @parent.inner_values
  let @body.types = @parent.inner_types
}

(let_declaration pattern: (_) @pat) @stmt {
  node @stmt.out_scope
  edge @stmt.out_scope -> @pat.defs
  attr (@stmt.out_scope -> @pat.defs) precedence = 1
  edge @stmt.out_scope -> @stmt.scope
}

[
  (expression_statement) @stmt
  (line_comment) @stmt
] {
  let @stmt.out_scope = @stmt.scope
}

(block (_) @child) @parent {
  let @child.types = @parent.types
}

(block (_)* @children) @parent {
  var current_scope = @parent.scope
  for child in @children {
    let child.scope = current_scope
    set current_scope = child.out_scope
  }
}

;; Other contexts that affect the scope of children:
;;   (field_initializer name: (_) @child) @parent
;;   (scoped_identifier name: (_) @child) @parent
;;   (scoped_type_identifier name: (_) @child) @parent

;; Propagate scope for all syntax that does not introduce bindings.
[
  ;; Items in the file-level module scope
  (source_file (_) @child) @parent

  ;; === Types
  ;; function_type is not listed because it can have `for_lifetimes`,
  ;; which affect the scope of its children.
  (abstract_type trait: (_) @child) @parent
  (array_type element: (_) @child) @parent
  (array_type length: (_) @child) @parent
  (bounded_type (_) @child) @parent
  (dynamic_type trait: (_) @child) @parent
  (generic_type type: (_) @child) @parent
  (generic_type type_arguments: (_) @child) @parent
  (pointer_type type: (_) @child) @parent
  (reference_type (lifetime) @child) @parent
  (reference_type type: (_) @child) @parent
  (scoped_type_identifier path: (_) @child) @parent
  (tuple_type (_) @child) @parent
  (type_arguments (_) @child) @parent

  ;; === Expressions
  (arguments (_) @child) @parent
  (array_expression (_) @child) @parent
  (array_expression length: (_) @child) @parent
  (assignment_expression left: (_) @child) @parent
  (assignment_expression right: (_) @child) @parent
  (async_block (_) @child) @parent
  (await_expression (_) @child) @parent
  (base_field_initializer (_) @child) @parent
  (binary_expression left: (_) @child) @parent
  (binary_expression right: (_) @child) @parent
  (break_expression (_) @child) @parent
  (call_expression function: (_) @child) @parent
  (call_expression arguments: (_) @child) @parent
  (closure_expression parameters: (_) @child) @parent
  (closure_expression return_type: (_) @child) @parent
  (compound_assignment_expr left: (_) @child) @parent
  (compound_assignment_expr right: (_) @child) @parent
  (const_block body: (_) @child) @parent
  (continue_expression (_) @child) @parent
  (else_clause (_) @child) @parent
  (field_expression value: (_) @child) @parent
  (field_initializer_list (_) @child) @parent
  (field_initializer value: (_) @child) @parent
  (for_expression pattern: (_) @child) @parent
  (for_expression value: (_) @child) @parent
  (generic_function function: (_) @child) @parent
  (generic_function type_arguments: (_) @child) @parent
  (if_expression condition: (_) @child) @parent
  (if_expression alternative: (_) @child) @parent
  (if_expression consequence: (_) @child) @parent
  (if_let_expression pattern: (_) @child) @parent
  (if_let_expression value: (_) @child) @parent
  (index_expression (_) @child) @parent
  (loop_expression body: (_) @child) @parent
  (macro_invocation macro: (_) @child) @parent
  (match_arm pattern: (_) @child) @parent
  (match_block (_) @child) @parent
  (match_expression value: (_) @child) @parent
  (match_expression body: (_) @child) @parent
  (match_pattern (_) @child (_)*) @parent
  (parenthesized_expression (_) @child) @parent
  (range_expression (_) @child) @parent
  (reference_expression value: (_) @child) @parent
  (return_expression (_) @child) @parent
  (scoped_identifier path: (_) @child) @parent
  (shorthand_field_initializer (_) @child) @parent
  (struct_expression name: (_) @child) @parent
  (struct_expression body: (_) @child) @parent
  (try_expression (_) @child) @parent
  (tuple_expression (_) @child) @parent
  (type_cast_expression value: (_) @child) @parent
  (type_cast_expression type: (_) @child) @parent
  (unary_expression (_) @child) @parent
  (unsafe_block (_) @child) @parent
  (while_expression condition: (_) @child) @parent
  (while_expression body: (_) @child) @parent
  (while_let_expression pattern: (_) @child) @parent
  (while_let_expression value: (_) @child) @parent
  (yield_expression (_) @child) @parent

  ;; === Statements
  (let_declaration pattern: (_) @child) @parent
  (let_declaration type: (_) @child) @parent
  (let_declaration value: (_) @child) @parent
  (expression_statement (_) @child) @parent

  ;; === Patterns
  (captured_pattern (identifier) "@" (_) @child) @parent
  (captured_pattern (identifier) @child "@" (_)) @parent
  (field_pattern (_) @child) @parent
  (mut_pattern (mutable_specifier) (_) @child) @parent
  (or_pattern (_) @child) @parent
  (range_pattern (_) @child) @parent
  (ref_pattern (_) @child) @parent
  (reference_pattern (_) @child) @parent
  (scoped_identifier path: (_) @child) @parent
  (slice_pattern (_) @child) @parent
  (struct_pattern (_) @child) @parent
  (tuple_pattern (_) @child) @parent
  (tuple_struct_pattern (_) @child) @parent

  ;; === Items
  ;; Of course all items are declarations and introduce bindings into the
  ;; enclosing scope. But the real reason fn/impl/struct/enum/union/type/trait
  ;; are not here is that they can have type parameters, which affect the scope
  ;; of everything in them. (Functions, of course, can even have regular old
  ;; function parameters. Worse and worse!)
  ;;
  ;; The names of all these items, though, are in the enclosing scope (so that
  ;; you can look them up and they'll find themselves).
  ;;
  ;; Modules are not present because they reset the scope. `foreign_mod_item`
  ;; is what the Rust reference calls an `ExternBlock` or "external block".
  ;; It's not a module and it does propagate scope.
  (const_item name: (_) @child) @parent
  (const_item type: (_) @child) @parent
  (const_item value: (_) @child) @parent
  (declaration_list (_) @child) @parent
  (enum_item name: (_) @child) @parent
  (enum_variant_list (_) @child) @parent
  (enum_variant body: (_) @child) @parent
  (enum_variant value: (_) @child) @parent
  (field_declaration type: (_) @child) @parent
  (field_declaration_list (_) @child) @parent
  (ordered_field_declaration_list (_) @child) @parent
  (foreign_mod_item body: (_) @child) @parent
  (function_item name: (_) @child) @parent
  (parameter pattern: (_) @child) @parent
  (parameter type: (_) @child) @parent
  (self_parameter (lifetime) @child) @parent
  (parameters (_) @child) @parent
  (static_item type: (_) @child) @parent
  (static_item value: (_) @child) @parent
  (struct_item name: (_) @child) @parent
  (trait_item name: (_) @child) @parent
  (type_item name: (_) @child) @parent
  (union_item name: (_) @child) @parent
  (where_clause (where_predicate) @child) @parent
  (where_predicate left: (_) @child) @parent
  (where_predicate bounds: (_) @child) @parent
  (trait_bounds (_) @child) @parent
  (removed_trait_bound (_) @child) @parent
] {
  let @child.scope = @parent.scope
  let @child.types = @parent.types
}

;; List all contexts where an identifier is a reference to a binding in the
;; "values" namespace.
;;
;; In many contexts, it is not:
;; -   after `:`, or before `::`, or inside `<...>`,
;;     it refers to something in the type namespace
;; -   in `#[...]` it refers to an attribute, or something
;; -   before `!` it refers to a macro
;; -   between `.` and `(` it refers to a method
;; -   otherwise after `.` it refers to a field
;; -   and of course, if it's the name of an item or binding,
;;     it isn't a reference at all.
[
  ;; === Expressions
  (arguments (identifier) @ident)
  (array_expression (identifier) @ident)
  (assignment_expression left: (identifier) @ident)
  (assignment_expression right: (identifier) @ident)
  (await_expression (identifier) @ident)
  (base_field_initializer (identifier) @ident)
  (binary_expression left: (identifier) @ident)
  (binary_expression right: (identifier) @ident)
  (break_expression (identifier) @ident)
  (call_expression function: (identifier) @ident)
  (compound_assignment_expr left: (identifier) @ident)
  (compound_assignment_expr right: (identifier) @ident)
  (field_expression value: (identifier) @ident)
  (field_initializer value: (identifier) @ident)
  (for_expression value: (identifier) @ident)
  (generic_function function: (identifier) @ident)
  (if_expression condition: (identifier) @ident)
  (if_let_expression value: (identifier) @ident)
  (index_expression (identifier) @ident)
  (match_expression value: (identifier) @ident)
  (match_pattern (_) "if" (identifier) @ident)
  (parenthesized_expression (identifier) @ident)
  (range_expression (identifier) @ident)
  (reference_expression value: (identifier) @ident)
  (return_expression (identifier) @ident)
  (shorthand_field_initializer (identifier) @ident)
  (try_expression (identifier) @ident)
  (tuple_expression (identifier) @ident)
  (type_cast_expression value: (identifier) @ident)
  (unary_expression (identifier) @ident)
  (while_expression condition: (identifier) @ident)
  (while_let_expression value: (identifier) @ident)
  (yield_expression (identifier) @ident)

  ;; === Types
  (array_type length: (identifier) @ident)

  ;; === Statements
  (block (_)* (identifier) @ident)
  (expression_statement (identifier) @ident)
  (let_declaration value: (identifier) @ident)

  ;; === Items
  (const_item value: (identifier) @ident)
  (static_item value: (identifier) @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident
  edge @ident.use -> @ident.scope
}

;; List all contexts where an identifier is a reference to a binding in the
;; "types" namespace.
[
  ;; === Types
  (abstract_type trait: (type_identifier) @ident)
  (array_type element: (type_identifier) @ident)
  (bounded_type (type_identifier) @ident)
  (dynamic_type trait: (type_identifier) @ident)
  (function_type trait: (type_identifier) @ident)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (type_identifier) @ident)
  (generic_type type: (type_identifier) @ident)
  (generic_type_with_turbofish type: (type_identifier) @ident)
  (pointer_type type: (type_identifier) @ident)
  (reference_type type: (type_identifier) @ident)
  ;; Scoped identifiers are more complicated than that, so comment them out for now.
  ;; (Also the scoped_identifier nodes in use_item nodes should not match.)
  ;; Definitely lexical scopes have a types/values split; what about other namespaces,
  ;; like the one under a trait, a struct, a module...?
  ;;(scoped_identifier path: (identifier) @ident)
  (tuple_type (type_identifier) @ident)
  (type_arguments (type_identifier) @ident) ;; questionable

  ;; === Expressions
  (type_cast_expression type: (type_identifier) @ident)
  (bracketed_type (type_identifier) @ident)
  (struct_expression name: (type_identifier) @ident)

  ;; === Patterns
  (struct_pattern type: (type_identifier) @ident)

  ;; === Items
  (const_item type: (type_identifier) @ident)
  (constrained_type_parameter left: (type_identifier) @ident)
  (field_declaration type: (type_identifier) @ident)
  (function_item return_type: (type_identifier) @ident)
  (impl_item trait: (type_identifier) @ident)
  (ordered_field_declaration_list type: (type_identifier) @ident)
  (parameter type: (type_identifier) @ident)
  (static_item type: (type_identifier) @ident)
  (trait_bounds (type_identifier) @ident)
  (where_predicate left: (type_identifier) @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident
  edge @ident.use -> @ident.types
}

[
  (const_item name: (_) @name) @item
  (enum_item name: (_) @name) @item
  (function_item name: (_) @name) @item
  (struct_item name: (_) @name) @item
  (union_item name: (_) @name) @item
] {
  node @item.def
  attr (@item.def) node_definition = @name
}

[
  (const_item name: (_) @name) @item
  (struct_item name: (_) @name) @item
  (function_item name: (_) @name) @item
] {
  edge @item.scope -> @item.def
}

[
  (enum_item name: (_) @name) @item
  (struct_item name: (_) @name) @item
  (union_item name: (_) @name) @item
] {
  edge @item.types -> @item.def
}

(parameters)@parameters {
  node @parameters.defs
}

(parameters (parameter pattern: (_) @pattern)) @parameters {
  edge @parameters.defs -> @pattern.defs
}

;; === Fields
;; Link fields in struct expressions and patterns to their definitions.

(struct_item)@struct {
  node @struct.fields
  attr (@struct.fields) pop_symbol = "%fields"
  edge @struct.def -> @struct.fields
}

(struct_item
  body: (field_declaration_list (field_declaration name: (_) @field))
) @struct {
  node @field.def
  attr (@field.def) node_definition = @field
  edge @struct.fields -> @field.def
}

(struct_expression
  name: (_) @ty
  body: (field_initializer_list [
    (field_initializer name: (field_identifier) @field_name)
    (shorthand_field_initializer (identifier) @field_name)
  ])
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}

(struct_pattern
  type: (_) @ty
  (field_pattern name: (_) @field_name)
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}

;; === Lifetimes
;; See also `(type_parameters (lifetime) @lifetime) @params` above.

;; Uses of lifetimes.
[
  (where_predicate left: (lifetime) @lifetime)
  (trait_bounds (lifetime) @lifetime)
  (constrained_type_parameter left: (lifetime) @lifetime)
  (self_parameter (lifetime) @lifetime)
  (bounded_type (lifetime) @lifetime)
  (type_arguments (lifetime) @lifetime)
  (reference_type (lifetime) @lifetime)
] {
  node @lifetime.use
  attr (@lifetime.use) node_reference = @lifetime
  edge @lifetime.use -> @lifetime.types
}