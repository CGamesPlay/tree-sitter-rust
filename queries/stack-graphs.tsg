; ####
; Rust
; ####
;
; All nodes that can contain uses must have:
;
;     .scope - The value namespace of the lexical scope in which the
;         syntax-node appears--that is, the *enclosing* lexical scope. This
;         namespace is used for looking up functions, local variables,
;         arguments, consts, statics, and constructors.
;
; Rust has separate value and type namespaces. That is, every lexical scope can
; contain both value bindings and type bindings, and they're distinct, as
; though the things in the type namespace (types, modules, crates) always had
; names that started with a special invisible sigil. For now we represent the
; type namespace as a separate node. There's an edge from every `.scope` that
; can contain type bindings to the corresponding type-namespace node, which
; pops a special symbol `"%type"`.
;
; Thus references to values can just push the identifier and go to the scope;
; but references to types must push the type-identifier, then push `"%type"`,
; then go to the scope.
;
; Lifetimes have their own separate namespace in Rust, but we put them in the
; type-namespace nodes. Since lifetimes always start with an apostrophe, there
; can't be any confusion.
;
; The .scope tree is stitched together with edges that point "up" the tree,
; toward the root. These trees stop at module nodes, because in Rust, modules
; do not inherit access to the enclosing block or module's bindings.
;
; The identifier syntax-node of an item's name or a binding name in a pattern
; has:
;
;     .def - The node that pops the item's name.
;
; Items also have a `.def` that aliases this node.
;
; For convenience, some nodes have:
;
;     .defs - A static-environment rib: a stepping-stone node from a scope node
;         toward actual local definitions, but without any inheritance edges.
;         These are stitched together with edges that point down the tree,
;         toward the leaves. They're necessary when we can't match the full path
;         from a scope to a binding with a single pattern.
;
; Note: Tree-sitter's Rust parser tries to distinguish various uses of
; identifiers and give them different syntax-node names (like
; `type_identifier`), but it's imprecise, and there are ambiguous cases built
; into the Rust language. We therefore often have to make a long list of
; exactly what nodes or contexts we're talking about.

; Magic invocations copied from tree-sitter-typescript.
attribute node_reference = node         => type = "push_symbol", symbol = (source-text node), is_reference, source_node = node
attribute node_symbol = node            => symbol = (source-text node), source_node = node
attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol

;; # Scope nodes

;; In which we attach `.scope` nodes to every syntax node that needs them, and
;; connect these nodes in a scope tree.
;;
;; Most nodes simply inherit these scopes from their parent. The last rule of
;; this section is a massive query listing every one of these trivial cases.
;; The rest of the section covers the special cases.

;; ## Root scopes
[
  (source_file) @root
  (mod_item body: (declaration_list) @root)
] {
  ;; New nodes, no inheritance.
  node @root.scope
  node @root.def_types
  attr (@root.def_types) pop_symbol = "%type"
  edge @root.scope -> @root.def_types
  attr (@root.scope -> @root.def_types) precedence = 1
}

;; ## Expression scopes

;; Expressions that introduce local bindings, either with patterns or loop
;; labels.
[
  (for_expression (loop_label)? @label pattern: (_) @pat) @parent
  (if_let_expression pattern: (_) @pat) @parent
  (loop_expression (loop_label)? @label) @parent
  (match_arm pattern: (_) @pat) @parent
  (while_expression (loop_label)? @label) @parent
  (while_let_expression (loop_label)? @label pattern: (_) @pat) @parent
] {
  if some @label {
    node @parent.inner_scope
    edge @parent.inner_scope -> @parent.scope
    if some @pat {
      ;; Here and throughout, an edge from a scope node to definition nodes has
      ;; precedence 1, higher than scope-inheritance edges (precedence 0), so that
      ;; inner bindings are preferred over (i.e. they shadow) outer bindings.
      edge @parent.inner_scope -> @pat.defs
      attr (@parent.inner_scope -> @pat.defs) precedence = 1
    }

    node def_loops
    attr (def_loops) pop_symbol = "%loop"
    edge @parent.inner_scope -> def_loops
    attr (@parent.inner_scope -> def_loops) precedence = 1

    ; Bind the label in the loop namespace
    node @label.def
    attr (@label.def) node_definition = @label
    edge def_loops -> @label.def
  } else {
    if some @pat {
      node @parent.inner_scope
      edge @parent.inner_scope -> @parent.scope
      edge @parent.inner_scope -> @pat.defs
      attr (@parent.inner_scope -> @pat.defs) precedence = 1
    } else {
      let @parent.inner_scope = @parent.scope
    }
  }
}

;; Assign the children of these expressions the inner_scope of their parents.
[
  (for_expression body: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (loop_expression body: (_) @child) @parent
  (match_arm pattern: (match_pattern condition: (_) @child)) @parent
  (match_arm value: (_) @child) @parent
  (while_expression body: (_) @child) @parent
  (while_let_expression body: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
}

;; Create the "definitions" node for each pattern. This query matches only the
;; outermost node of each pattern. Parameters are awkward so they're dealt with
;; elsewhere.
[
  (for_expression pattern: (_) @pat)
  (if_let_expression pattern: (_) @pat)
  (match_arm pattern: (_) @pat)
  (while_let_expression pattern: (_) @pat)
  (let_declaration pattern: (_) @pat)
  (closure_parameters (_) @pat)
] {
  node @pat.defs
}

;; Subpatterns inherit the parent's defs node.
[
  (captured_pattern (identifier) "@" (_) @pat) @parent
  (captured_pattern (identifier) @pat "@" (_)) @parent
  (field_pattern name: (shorthand_field_identifier) @pat) @parent
  (field_pattern pattern: (_) @pat) @parent
  (match_pattern . (_) @pat) @parent
  (mut_pattern (mutable_specifier) (_) @pat) @parent
  (or_pattern (_) @pat) @parent
  (ref_pattern (_) @pat) @parent
  (reference_pattern "&" (mutable_specifier)? (_) @pat) @parent
  (slice_pattern (_) @pat) @parent
  (struct_pattern (field_pattern) @pat) @parent
  (tuple_pattern (_) @pat) @parent
  (tuple_struct_pattern type: (_) (_) @pat) @parent
] {
  let @pat.defs = @parent.defs
}

;; Identifier-patterns are definitions.
[
  (for_expression pattern: (identifier) @ident)
  (if_let_expression pattern: (identifier) @ident)
  (while_let_expression pattern: (identifier) @ident)
  (let_declaration pattern: (identifier) @ident)
  (parameter pattern: (identifier) @ident)
  (closure_parameters (identifier) @ident)
  (match_pattern . (identifier) @ident)
  (tuple_pattern (identifier) @ident)
  (tuple_struct_pattern type: (_) (identifier) @ident)
  (slice_pattern (identifier) @ident)
  (field_pattern name: (shorthand_field_identifier) @ident)
  (field_pattern pattern: (identifier) @ident)
  (mut_pattern (mutable_specifier) (identifier) @ident)
  (ref_pattern (identifier) @ident)
  (captured_pattern (identifier) @ident "@" (_))
  (reference_pattern "&" (mutable_specifier)? (identifier) @ident)
  (or_pattern (identifier) @ident)
] {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @ident.defs -> @ident.def
}

;; ## Generic parameters

;; Items that have a `type_parameters` child have an `.inner_types` node
;; that is the type namespace presented to their children.
[
  (associated_type type_parameters: (type_parameters)? @params) @parent
  (enum_item type_parameters: (type_parameters)? @params) @parent
  (function_item type_parameters: (type_parameters)? @params) @parent
  (function_signature_item type_parameters: (type_parameters)? @params) @parent
  (impl_item type_parameters: (type_parameters)? @params) @parent
  (struct_item type_parameters: (type_parameters)? @params) @parent
  (trait_item type_parameters: (type_parameters)? @params) @parent
  (type_item type_parameters: (type_parameters)? @params) @parent
  (union_item type_parameters: (type_parameters)? @params) @parent
  (function_type (for_lifetimes)? @params) @parent
] {
  if some @params {
    node @parent.inner_scope
    edge @parent.inner_scope -> @parent.scope

    node @params.const_param_defs
    edge @parent.inner_scope -> @params.const_param_defs
    attr (@parent.inner_scope -> @params.const_param_defs) precedence = 1

    node @params.type_param_defs
    attr (@params.type_param_defs) pop_symbol = "%type"
    edge @parent.inner_scope -> @params.type_param_defs
    attr (@parent.inner_scope -> @params.type_param_defs) precedence = 1
  } else {
    ;; Items that could have type parameters, but in fact don't, also need
    ;; `inner` nodes, but they're just the same node as the enclosing ones.
    let @parent.inner_scope = @parent.scope
  }
}

; Generic parameters are definitions.
[
  (type_parameters (lifetime) @lifetime) @params
  (for_lifetimes (lifetime) @lifetime) @params
] {
  node @lifetime.def
  attr (@lifetime.def) node_definition = @lifetime
  edge @params.type_param_defs -> @lifetime.def
}

(type_parameters (type_identifier) @ident) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.type_param_defs -> @ident.def
}

(type_parameters (const_parameter name: (_) @ident)) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.const_param_defs -> @ident.def
}

;; Direct children of generics get the inner scope.
;;
;; This lists all contexts in most items, except the name,
;; and all contexts within a function except the name and the body;
;; the body is special because it also sees the function parameter bindings.
[
  (associated_type type_parameters: (_) @child) @parent
  (associated_type bounds: (_) @child) @parent
  (enum_item type_parameters: (_) @child) @parent
  (enum_item (where_clause) @child) @parent
  (enum_item body: (_) @child) @parent
  (function_item type_parameters: (_) @child) @parent
  (function_item parameters: (_) @child) @parent
  (function_item return_type: (_) @child) @parent
  (function_item (where_clause) @child) @parent
  (function_signature_item (_) @child) @parent
  (impl_item type_parameters: (_) @child) @parent
  (impl_item trait: (_) @child) @parent
  (impl_item type: (_) @child) @parent
  (impl_item (where_clause) @child) @parent
  (impl_item body: (_) @child) @parent
  (struct_item type_parameters: (_) @child) @parent
  (struct_item (where_clause) @child) @parent
  (struct_item body: (_) @child) @parent
  (trait_item type_parameters: (_) @child) @parent
  (trait_item bounds: (_) @child) @parent
  (trait_item (where_clause) @child) @parent
  (trait_item body: (_) @child) @parent
  (type_item type_parameters: (_) @child) @parent
  (type_item type: (_) @child) @parent
  (union_item type_parameters: (_) @child) @parent
  (union_item body: (_) @child) @parent

  (function_type trait: (_) @child) @parent  ;; only for Fn, FnMut, FnOnce
  (function_type parameters: (_) @child) @parent
  (function_type return_type: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
}

;; ## Block scopes.
;;
;; Items in a block are visible throughout the block. Let-declaration bindings
;; in a block are visible starting with the next statement or expression.

;; Create the item scope.
(block) @block {
  ;; TODO: Figure out how to create these nodes conditionally. They're only
  ;; needed if the block contains items; otherwise these can just be aliases.
  ;; The reason it isn't done is I don't know how to use the query language
  ;; to distinguish blocks that have items from those that don't.
  node @block.item_scope
  edge @block.item_scope -> @block.scope

  node @block.item_types
  attr (@block.item_types) pop_symbol = "%type"
  edge @block.item_scope -> @block.item_types
  attr (@block.item_scope -> @block.item_types) precedence = 1
}

;; The next two rules define each child's `.scope`.
(block . (_) @first_child) @block {
  let @first_child.scope = @block.item_scope
}

(block (_) @prev . (_) @next) {
  let @next.scope = @prev.block_scope_after
}

;; The next two rules define `.block_scope_after` for each statement child.
(let_declaration pattern: (_) @pat) @stmt {
  node @stmt.block_scope_after
  edge @stmt.block_scope_after -> @pat.defs
  attr (@stmt.block_scope_after -> @pat.defs) precedence = 1
  edge @stmt.block_scope_after -> @stmt.scope
}

(block [
  ;; This is every node type that can appear in a block as a statement, except
  ;; `let_declaration`. Awkward but I don't know how else to write this.
  (empty_statement)
  (expression_statement)
  (line_comment)
  (macro_definition)
  (attribute_item)
  (inner_attribute_item)

  (const_item)
  (mod_item)
  (foreign_mod_item)
  (struct_item)
  (union_item)
  (enum_item)
  (type_item)
  (function_item)
  (function_signature_item)
  (impl_item)
  (trait_item)
  (associated_type)
  (use_declaration)
  (extern_crate_declaration)
  (static_item)
] @stmt) {
  let @stmt.block_scope_after = @stmt.scope
}


;; Default scope propagation
;;
;; Propagate scope for all syntax that does not introduce bindings.
[
  ;; Items in the file-level module scope
  (source_file (_) @child) @parent

  ;; ### Types
  ;; function_type is not listed because it can have `for_lifetimes`,
  ;; which affect the scope of its children.
  (abstract_type trait: (_) @child) @parent
  (array_type element: (_) @child) @parent
  (array_type length: (_) @child) @parent
  (bounded_type (_) @child) @parent
  (dynamic_type trait: (_) @child) @parent
  (generic_type type: (_) @child) @parent
  (generic_type type_arguments: (_) @child) @parent
  (pointer_type type: (_) @child) @parent
  (reference_type (lifetime) @child) @parent
  (reference_type type: (_) @child) @parent
  (scoped_type_identifier path: (_) @child) @parent
  (tuple_type (_) @child) @parent
  (type_arguments (_) @child) @parent
  ;;(type_binding type_arguments: (_) @child) @parent  ;; bogus grammar
  (type_binding type: (_) @child) @parent

  ;; ### Expressions
  (arguments (_) @child) @parent
  (array_expression (_) @child) @parent
  (array_expression length: (_) @child) @parent
  (assignment_expression left: (_) @child) @parent
  (assignment_expression right: (_) @child) @parent
  (async_block (_) @child) @parent
  (await_expression (_) @child) @parent
  (base_field_initializer (_) @child) @parent
  (binary_expression left: (_) @child) @parent
  (binary_expression right: (_) @child) @parent
  (break_expression (_) @child) @parent
  (call_expression function: (_) @child) @parent
  (call_expression arguments: (_) @child) @parent
  (closure_expression parameters: (_) @child) @parent
  (closure_expression return_type: (_) @child) @parent
  (compound_assignment_expr left: (_) @child) @parent
  (compound_assignment_expr right: (_) @child) @parent
  (const_block body: (_) @child) @parent
  (continue_expression (_) @child) @parent
  (else_clause (_) @child) @parent
  (field_expression value: (_) @child) @parent
  (field_initializer_list (_) @child) @parent
  (field_initializer value: (_) @child) @parent
  (for_expression pattern: (_) @child) @parent
  (for_expression value: (_) @child) @parent
  (generic_function function: (_) @child) @parent
  (generic_function type_arguments: (_) @child) @parent
  (if_expression condition: (_) @child) @parent
  (if_expression alternative: (_) @child) @parent
  (if_expression consequence: (_) @child) @parent
  (if_let_expression pattern: (_) @child) @parent
  (if_let_expression value: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (index_expression (_) @child) @parent
  (macro_invocation macro: (_) @child) @parent
  (match_arm pattern: (_) @child) @parent
  (match_block (_) @child) @parent
  (match_expression value: (_) @child) @parent
  (match_expression body: (_) @child) @parent
  (match_pattern . (_) @child) @parent
  (parenthesized_expression (_) @child) @parent
  (range_expression (_) @child) @parent
  (reference_expression value: (_) @child) @parent
  (return_expression (_) @child) @parent
  (scoped_identifier path: (_) @child) @parent
  (shorthand_field_initializer (_) @child) @parent
  (struct_expression name: (_) @child) @parent
  (struct_expression body: (_) @child) @parent
  (try_expression (_) @child) @parent
  (tuple_expression (_) @child) @parent
  (type_cast_expression value: (_) @child) @parent
  (type_cast_expression type: (_) @child) @parent
  (unary_expression (_) @child) @parent
  (unsafe_block (_) @child) @parent
  (while_expression condition: (_) @child) @parent
  (while_let_expression pattern: (_) @child) @parent
  (while_let_expression value: (_) @child) @parent
  (yield_expression (_) @child) @parent

  ;; ### Statements
  (let_declaration pattern: (_) @child) @parent
  (let_declaration type: (_) @child) @parent
  (let_declaration value: (_) @child) @parent
  (expression_statement (_) @child) @parent

  ;; ### Patterns
  (captured_pattern (identifier) "@" (_) @child) @parent
  (captured_pattern (identifier) @child "@" (_)) @parent
  (field_pattern (_) @child) @parent
  (mut_pattern (mutable_specifier) (_) @child) @parent
  (or_pattern (_) @child) @parent
  (range_pattern (_) @child) @parent
  (ref_pattern (_) @child) @parent
  (reference_pattern (_) @child) @parent
  (scoped_identifier path: (_) @child) @parent
  (slice_pattern (_) @child) @parent
  (struct_pattern (_) @child) @parent
  (tuple_pattern (_) @child) @parent
  (tuple_struct_pattern (_) @child) @parent

  ;; ### Items
  ;; Of course all items are declarations and introduce bindings into the
  ;; enclosing scope. But the real reason fn/impl/struct/enum/union/type/trait
  ;; are not here is that they can have type parameters, which affect the scope
  ;; of everything in them. (Functions, of course, can even have regular old
  ;; function parameters. Worse and worse!)
  ;;
  ;; The names of all these items, though, are in the enclosing scope (so that
  ;; you can look them up and they'll find themselves).
  ;;
  ;; Modules are not present because they reset the scope. `foreign_mod_item`
  ;; is what the Rust reference calls an `ExternBlock` or "external block".
  ;; It's not a module and it does propagate scope.
  (const_item name: (_) @child) @parent
  (const_item type: (_) @child) @parent
  (const_item value: (_) @child) @parent
  (declaration_list (_) @child) @parent
  (enum_item name: (_) @child) @parent
  (enum_variant_list (_) @child) @parent
  (enum_variant body: (_) @child) @parent
  (enum_variant value: (_) @child) @parent
  (field_declaration type: (_) @child) @parent
  (field_declaration_list (_) @child) @parent
  (ordered_field_declaration_list (_) @child) @parent
  (foreign_mod_item body: (_) @child) @parent
  (function_item name: (_) @child) @parent
  (parameter pattern: (_) @child) @parent
  (parameter type: (_) @child) @parent
  (self_parameter (lifetime) @child) @parent
  (parameters (_) @child) @parent
  (static_item type: (_) @child) @parent
  (static_item value: (_) @child) @parent
  (struct_item name: (_) @child) @parent
  (trait_item name: (_) @child) @parent
  (type_item name: (_) @child) @parent
  (union_item name: (_) @child) @parent
  (where_clause (where_predicate) @child) @parent
  (where_predicate left: (_) @child) @parent
  (where_predicate bounds: (_) @child) @parent
  (trait_bounds (_) @child) @parent
  (removed_trait_bound (_) @child) @parent
] {
  let @child.scope = @parent.scope
}



;; # Marking unqualified references

;; List all contexts where an identifier is a reference to a binding in the
;; "values" namespace.
;;
;; In many contexts, it is not:
;; -   after `let x:`, or before `::`, or inside `<...>`, or after `as`,
;;     it refers to something in the type namespace
;; -   in `#[...]` it refers to an attribute, or something
;; -   before `!` it refers to a macro
;; -   between `.` and `(` it refers to a method
;; -   otherwise after `.` it refers to a field
;; -   and of course, if it's the `name:` of an item or binding,
;;     it isn't a reference at all.
;;
;; The grammar parses many of these as `identifier` syntax nodes, so it's
;; necessary to use a giant pattern to get only expression contexts.
[
  ;; ### Expressions
  (arguments [(identifier) (self)] @ident)
  (array_expression [(identifier) (self)] @ident)
  (assignment_expression left: [(identifier) (self)] @ident)
  (assignment_expression right: [(identifier) (self)] @ident)
  (await_expression [(identifier) (self)] @ident)
  (base_field_initializer [(identifier) (self)] @ident)
  (binary_expression left: [(identifier) (self)] @ident)
  (binary_expression right: [(identifier) (self)] @ident)
  (break_expression [(identifier) (self)] @ident)
  (call_expression function: [(identifier) (self)] @ident)
  (compound_assignment_expr left: [(identifier) (self)] @ident)
  (compound_assignment_expr right: [(identifier) (self)] @ident)
  (field_expression value: [(identifier) (self)] @ident)
  (field_initializer value: [(identifier) (self)] @ident)
  (for_expression value: [(identifier) (self)] @ident)
  (generic_function function: [(identifier) (self)] @ident)
  (if_expression condition: [(identifier) (self)] @ident)
  (if_let_expression value: [(identifier) (self)] @ident)
  (index_expression [(identifier) (self)] @ident)
  (match_expression value: [(identifier) (self)] @ident)
  (match_pattern condition: [(identifier) (self)] @ident)
  (parenthesized_expression [(identifier) (self)] @ident)
  (range_expression [(identifier) (self)] @ident)
  (reference_expression value: [(identifier) (self)] @ident)
  (return_expression [(identifier) (self)] @ident)
  (shorthand_field_initializer [(identifier) (self)] @ident)
  (try_expression [(identifier) (self)] @ident)
  (tuple_expression [(identifier) (self)] @ident)
  (type_cast_expression value: [(identifier) (self)] @ident)
  (unary_expression [(identifier) (self)] @ident)
  (while_expression condition: [(identifier) (self)] @ident)
  (while_let_expression value: [(identifier) (self)] @ident)
  (yield_expression [(identifier) (self)] @ident)

  ;; ### Types
  (array_type length: [(identifier) (self)] @ident)

  ;; ### Statements
  (block (_)* [(identifier) (self)] @ident)
  (expression_statement [(identifier) (self)] @ident)
  (let_declaration value: [(identifier) (self)] @ident)

  ;; ### Items
  (const_item value: [(identifier) (self)] @ident)
  (static_item value: [(identifier) (self)] @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident
  edge @ident.use -> @ident.scope
}

;; List all contexts where an identifier is a reference to a binding in the
;; "types" namespace of the current scope.
;;
;; The grammar also parses the following as `type_identifier`:
;; - names of many items, like the `X` in `struct X {}`
;; - type parameters, like the `T` in `fn f<T>() {}`
;; - the `Item` in `Iterator<Item=T>`
;; - identifiers after `::` when they refer to types
;; None of these should match here, so it's necessary to use a huge pattern to
;; get only type-expression contexts.
;;
;; Identifiers immediately before `::` in a `scoped_identifier` are also likely
;; just a bit different (I don't actually know) and are handled elsewhere for
;; now.
[
  ;; ### Types
  (abstract_type trait: (type_identifier) @ident)
  (array_type element: (type_identifier) @ident)
  (bounded_type (type_identifier) @ident)
  (dynamic_type trait: (type_identifier) @ident)
  (function_type trait: (type_identifier) @ident)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (type_identifier) @ident)
  (generic_type type: (type_identifier) @ident)
  (generic_type_with_turbofish type: (type_identifier) @ident)
  (pointer_type type: (type_identifier) @ident)
  (reference_type type: (type_identifier) @ident)
  (tuple_type (type_identifier) @ident)
  (type_arguments (type_identifier) @ident) ;; ambiguous, but treat as a type for now
  (type_binding type: (type_identifier) @ident)

  ;; ### Expressions
  (type_cast_expression type: (type_identifier) @ident)
  (bracketed_type (type_identifier) @ident)
  (struct_expression name: (type_identifier) @ident)

  ;; ### Patterns
  (struct_pattern type: (type_identifier) @ident)

  ;; ### Items
  (const_item type: (type_identifier) @ident)
  (constrained_type_parameter left: (type_identifier) @ident)
  (field_declaration type: (type_identifier) @ident)
  (function_item return_type: (type_identifier) @ident)
  (impl_item trait: (type_identifier) @ident)
  (impl_item type: (type_identifier) @ident)
  (ordered_field_declaration_list type: (type_identifier) @ident)
  (parameter type: (type_identifier) @ident)
  (static_item type: (type_identifier) @ident)
  (trait_bounds (type_identifier) @ident)
  (where_predicate left: (type_identifier) @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident

  let t = (node)
  attr (t) push_symbol = "%type"
  edge @ident.use -> t
  edge t -> @ident.scope
}

;; The type-tag in a tuple_struct_pattern is a gruesome special case in rustc.
;; It looks in both namespaces, preferring inner scopes to outer scopes, and
;; when it finds both a value and a type in the same lexical scope, picking the
;; type.
;;
;; Our graph can't implement this exactly, but we can get pretty close.
(tuple_struct_pattern type: (identifier) @ident) {
  node @ident.use
  attr (@ident.use) node_reference = @ident

  ;; Optional "%type" node!
  let t = (node)
  attr (t) push_symbol = "%type"
  edge @ident.use -> t
  attr (@ident.use -> t) precedence = 1
  edge t -> @ident.scope
  edge @ident.use -> @ident.scope
}



; # Item definitions

[
  (declaration_list (_) @child) @parent
  (source_file (_) @child) @parent
] {
  let @child.item_def_scope = @parent.scope
  let @child.item_def_types = @parent.def_types
}

;; Tell block-scoped items which node they should hang definitions on.
;;
;; (The two scoped variables `.item_def_scope` and `item_scope` look like they
;; ought to have the same name, but that wouldn't work. The selector here does
;; not select only item children but all children; one of those children might
;; be another block, and then there'd be a conflict.)
(block (_) @child) @parent {
  let @child.item_def_scope = @parent.item_scope
  let @child.item_def_types = @parent.item_types
}

[
  (const_item name: (_) @name)
  (enum_item name: (_) @name)
  (function_item name: (_) @name)
  (mod_item name: (_) @name)
  (struct_item name: (_) @name)
  (union_item name: (_) @name)
] @item {
  node @name.def
  attr (@name.def) node_definition = @name
  let @item.def = @name.def
}

; Bind items in the value namespace. Note: We bind structs in both namespaces.
; This is definitely correct for unit structs and tuple structs. Does Rust bind
; named-field structs in the value namespace? XXX TODO find out
[
  (const_item name: (_) @name)
  (struct_item name: (_) @name)
  (function_item name: (_) @name)
] @item {
  edge @item.item_def_scope -> @name.def
  attr (@item.item_def_scope -> @name.def) precedence = 1
}

; Bind items in the type namespace.
[
  (enum_item name: (_) @name)
  (struct_item name: (_) @name)
  (union_item name: (_) @name)
] @item {
  edge @item.item_def_types -> @name.def
  attr (@item.item_def_types -> @name.def) precedence = 1
}



;; # Function and closure parameters

;; This is awkward because `closure_parameters` have two different structures
;; only one of which (`parameter`) can be easily distinguished with a query.
;;
;; TODO - See if this can be made any tidier.

[(parameters) (closure_parameters)] @parameters {
  node @parameters.defs
}

[(parameter) (self_parameter)] @parameter {
  node @parameter.defs
}

[
  (parameters (parameter) @child)
  (parameters (self_parameter) @child)
  (closure_parameters (_) @child)
] @parameters {
  edge @parameters.defs -> @child.defs
}

(parameter pattern: (_) @pat) @param {
  let @pat.defs = @param.defs
}

(self_parameter (self) @self) @param {
  node @self.def
  attr (@self.def) node_definition = @self
  edge @param.defs -> @self.def
}

(closure_expression parameters: (_) @parameters body: (_) @body) @parent {
  node @body.scope
  edge @body.scope -> @parameters.defs
  attr (@body.scope -> @parameters.defs) precedence = 1
  edge @body.scope -> @parent.scope
}

(function_item parameters: (_) @parameters body: (_) @body) @parent {
  node @body.scope
  edge @body.scope -> @parameters.defs
  attr (@body.scope -> @parameters.defs) precedence = 1
  edge @body.scope -> @parent.inner_scope
}



;; # Fields
;; Link fields in struct expressions and patterns to their definitions.

(struct_item) @struct {
  node @struct.fields
  attr (@struct.fields) pop_symbol = "%fields"
  edge @struct.def -> @struct.fields
}

(struct_item
  body: (field_declaration_list (field_declaration name: (_) @field))
) @struct {
  node @field.def
  attr (@field.def) node_definition = @field
  edge @struct.fields -> @field.def
}

[
  (struct_expression
    body: (field_initializer_list
      (field_initializer name: (field_identifier) @field_name)
    )
  )
  (struct_pattern (field_pattern name: (_) @field_name))
] {
  node @field_name.use
  attr (@field_name.use) node_reference = @field_name
}

(struct_expression
  name: (type_identifier) @ty
  body: (field_initializer_list [
    (field_initializer name: (field_identifier) @field_name)
    (shorthand_field_initializer (identifier) @field_name)
  ])
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}

(struct_pattern
  type: (type_identifier) @ty
  (field_pattern name: (_) @field_name)
) {
  node push_fields
  attr (push_fields) push_symbol = "%fields"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}



;; # Lifetimes
;; See also `(type_parameters (lifetime) @lifetime) @params` above.

;; Uses of lifetimes.
[
  (where_predicate left: (lifetime) @lifetime)
  (trait_bounds (lifetime) @lifetime)
  (constrained_type_parameter left: (lifetime) @lifetime)
  (self_parameter (lifetime) @lifetime)
  (bounded_type (lifetime) @lifetime)
  (type_arguments (lifetime) @lifetime)
  (reference_type (lifetime) @lifetime)
] {
  node @lifetime.use
  attr (@lifetime.use) node_reference = @lifetime
  node t
  attr (t) push_symbol = "%type"
  edge @lifetime.use -> t
  edge t -> @lifetime.scope
}

;; # Loop labels
;; These look like lifetimes.
;; TODO - are they in the same namespace as lifetimes?

;; Uses of loop labels.
[
  (break_expression (loop_label) @label)
  (continue_expression (loop_label) @label)
] @expr {
  node @label.use
  attr (@label.use) node_reference = @label
  node t
  attr (t) push_symbol = "%loop"
  edge @label.use -> t
  edge t -> @expr.scope
}
