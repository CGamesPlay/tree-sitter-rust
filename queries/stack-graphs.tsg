; ####
; Rust
; ####
;
; All nodes that can contain uses must have:
;
;     .scope - The value namespace of the lexical scope in which the
;         syntax-node appears--that is, the *enclosing* lexical scope. This
;         namespace is used for looking up functions, local variables,
;         arguments, consts, statics, and constructors.
;
; Rust has separate value and type namespaces. That is, every lexical scope can
; contain both value bindings and type bindings, and they're distinct, as
; though the things in the type namespace (types, modules, crates) always had
; names that started with a special invisible sigil. For now we represent the
; type namespace as a separate node. There's an edge from every `.scope` that
; can contain type bindings to the corresponding type-namespace node, which
; pops a special symbol `"%type"`.
;
; Thus references to values can just push the identifier and go to the scope;
; but references to types must push the type-identifier, then push `"%type"`,
; then go to the scope.
;
; Lifetimes have their own separate namespace in Rust, but we put them in the
; type-namespace nodes. Since lifetimes always start with an apostrophe, there
; can't be any confusion.
;
; The .scope tree is stitched together with edges that point "up" the tree,
; toward the root. These trees stop at module nodes, because in Rust, modules
; do not inherit access to the enclosing block or module's bindings.
;
; The syntax-node of an item, type parameter, lifetime parameter, or binding name
; in a pattern has:
;
;     .def - The node that pops the item's name.
;
; Scope nodes have:
;
;     .def_values, .def_types - A static-environment rib: has paths to all
;         values/types defined in this scope, and not inherited from an
;         enclosing scope.
;
; These are sometimes stitched together with rules that walk "down" the
; syntax-tree, toward the leaves, which is necessary (e.g. in pattern syntax)
; when we can't match the full path from a scope to a binding with a single
; pattern.
;
; Children of scope nodes have:
;
;     .item_def_values, .item_def_types - The nodes to which this syntax-node
;         contributes items and imports.
;
; Note: Tree-sitter's Rust parser tries to distinguish various uses of
; identifiers and give them different syntax-node names (like
; `type_identifier`), but it's imprecise, and there are ambiguous cases built
; into the Rust language. We therefore often have to make long lists of
; exactly what nodes or contexts we're talking about.

global FILE_PATH
global ROOT_NODE

; Magic invocations copied from tree-sitter-typescript.
attribute node_reference = node         => type = "push_symbol", symbol = (source-text node), is_reference, source_node = node
attribute node_symbol = node            => symbol = (source-text node), source_node = node
attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol

;; # Scope nodes

;; In which we attach `.scope` nodes to every syntax node that needs them, and
;; connect these nodes in a scope tree.
;;
;; Most nodes simply inherit these scopes from their parent. The last rule of
;; this section is a massive query listing every one of these trivial cases.
;; The rest of the section covers the special cases.

;; ## Root scopes
[
  (source_file) @root
  (mod_item body: (declaration_list) @root)
] {
  ;; New nodes, no inheritance.
  node @root.scope
}

;; ## Expression scopes

;; Expressions that introduce local bindings, either with patterns or loop
;; labels.
[
  (for_expression (loop_label)? @label pattern: (_) @pat) @parent
  (if_let_expression pattern: (_) @pat) @parent
  (loop_expression (loop_label)? @label) @parent
  (match_arm pattern: (_) @pat) @parent
  (while_expression (loop_label)? @label) @parent
  (while_let_expression (loop_label)? @label pattern: (_) @pat) @parent
] {
  if some @label {
    node @parent.inner_scope
    edge @parent.inner_scope -> @parent.scope
    if some @pat {
      ;; Create the "definitions" node to which the pattern contributes bindings.
      ;;
      ;; A similar node is created everywhere patterns are used (let-declarations
      ;; and parameters).
      ;;
      ;; Here and throughout, an edge from a scope node to definition nodes has
      ;; precedence 1, higher than scope-inheritance edges (precedence 0), so that
      ;; inner bindings are preferred over (i.e. they shadow) outer bindings.
      node @pat.def_values
      attr (@pat.def_values) pop_symbol = "%value"
      edge @parent.inner_scope -> @pat.def_values
      attr (@parent.inner_scope -> @pat.def_values) precedence = 1
    }

    node def_loops
    attr (def_loops) pop_symbol = "%loop"
    edge @parent.inner_scope -> def_loops
    attr (@parent.inner_scope -> def_loops) precedence = 1

    ; Bind the label in the loop namespace
    node @label.def
    attr (@label.def) node_definition = @label
    edge def_loops -> @label.def
  } else {
    if some @pat {
      node @parent.inner_scope
      edge @parent.inner_scope -> @parent.scope

      node @pat.def_values
      attr (@pat.def_values) pop_symbol = "%value"
      edge @parent.inner_scope -> @pat.def_values
      attr (@parent.inner_scope -> @pat.def_values) precedence = 1
    } else {
      let @parent.inner_scope = @parent.scope
    }
  }
}

;; Subpatterns inherit the parent's defs node.
[
  (captured_pattern (identifier) "@" (_) @pat) @parent
  (captured_pattern (identifier) @pat "@" (_)) @parent
  (field_pattern name: (shorthand_field_identifier) @pat) @parent
  (field_pattern pattern: (_) @pat) @parent
  (match_pattern . (_) @pat) @parent
  (mut_pattern (mutable_specifier) (_) @pat) @parent
  (or_pattern (_) @pat) @parent
  (ref_pattern (_) @pat) @parent
  (reference_pattern "&" (mutable_specifier)? (_) @pat) @parent
  (slice_pattern (_) @pat) @parent
  (struct_pattern (field_pattern) @pat) @parent
  (tuple_pattern (_) @pat) @parent
  (tuple_struct_pattern type: (_) (_) @pat) @parent
] {
  let @pat.def_values = @parent.def_values
}

;; Assign the children of these expressions the inner_scope of their parents.
[
  (for_expression body: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (loop_expression body: (_) @child) @parent
  (match_arm pattern: (match_pattern condition: (_) @child)) @parent
  (match_arm value: (_) @child) @parent
  (while_expression body: (_) @child) @parent
  (while_let_expression body: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
}

;; Identifier-patterns are definitions.
;;
;; (This isn't entirely true. In Rust, if the identifier resolves to a constant
;; or enum variant, it's not a shadowing definition; instead it's a pattern
;; that matches that exact value. But it's not clear how such a rule can be
;; implemented.)
[
  (for_expression pattern: (identifier) @ident)
  (if_let_expression pattern: (identifier) @ident)
  (while_let_expression pattern: (identifier) @ident)
  (let_declaration pattern: (identifier) @ident)
  (parameter pattern: (identifier) @ident)
  (closure_parameters (identifier) @ident)
  (match_pattern . (identifier) @ident)
  (tuple_pattern (identifier) @ident)
  (tuple_struct_pattern type: (_) (identifier) @ident)
  (slice_pattern (identifier) @ident)
  (field_pattern name: (shorthand_field_identifier) @ident)
  (field_pattern pattern: (identifier) @ident)
  (mut_pattern (mutable_specifier) (identifier) @ident)
  (ref_pattern (identifier) @ident)
  (captured_pattern (identifier) @ident "@" (_))
  (reference_pattern "&" (mutable_specifier)? (identifier) @ident)
  (or_pattern (identifier) @ident)
] {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @ident.def_values -> @ident.def
}

;; ## Generic parameters

;; Items that have a `type_parameters` child have an `.inner_types` node
;; that is the type namespace presented to their children.
[
  (associated_type type_parameters: (type_parameters)? @params) @parent
  (enum_item type_parameters: (type_parameters)? @params) @parent
  (function_item type_parameters: (type_parameters)? @params) @parent
  (function_signature_item type_parameters: (type_parameters)? @params) @parent
  (impl_item type_parameters: (type_parameters)? @params) @parent
  (struct_item type_parameters: (type_parameters)? @params) @parent
  (trait_item type_parameters: (type_parameters)? @params) @parent
  (type_item type_parameters: (type_parameters)? @params) @parent
  (union_item type_parameters: (type_parameters)? @params) @parent
  (function_type (for_lifetimes)? @params) @parent
] {
  if some @params {
    node @parent.inner_scope
    edge @parent.inner_scope -> @parent.scope

    node @params.const_param_defs
    attr (@params.const_param_defs) pop_symbol = "%value"
    edge @parent.inner_scope -> @params.const_param_defs
    attr (@parent.inner_scope -> @params.const_param_defs) precedence = 1

    node @params.type_param_defs
    attr (@params.type_param_defs) pop_symbol = "%type"
    edge @parent.inner_scope -> @params.type_param_defs
    attr (@parent.inner_scope -> @params.type_param_defs) precedence = 1
  } else {
    ;; Items that could have type parameters, but in fact don't, also need
    ;; `inner` nodes, but they're just the same node as the enclosing ones.
    let @parent.inner_scope = @parent.scope
  }
}

; Generic parameters are definitions.
[
  (type_parameters (lifetime) @lifetime)
  (type_parameters (constrained_type_parameter left: (lifetime) @lifetime))
  (for_lifetimes (lifetime) @lifetime)
] @params {
  node @lifetime.def
  attr (@lifetime.def) node_definition = @lifetime
  edge @params.type_param_defs -> @lifetime.def
}

[
  (type_parameters (type_identifier) @ident)
  (type_parameters (constrained_type_parameter left: (type_identifier) @ident))
] @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.type_param_defs -> @ident.def
}

(type_parameters (const_parameter name: (_) @ident)) @params {
  node @ident.def
  attr (@ident.def) node_definition = @ident
  edge @params.const_param_defs -> @ident.def
}

;; Direct children of generics get the inner scope.
;;
;; This lists all contexts in most items, except the name,
;; and all contexts within a function except the name and the body;
;; the body is special because it also sees the function parameter bindings.
[
  (associated_type type_parameters: (_) @child) @parent
  (associated_type bounds: (_) @child) @parent
  (enum_item type_parameters: (_) @child) @parent
  (enum_item (where_clause) @child) @parent
  (enum_item body: (_) @child) @parent
  (function_item type_parameters: (_) @child) @parent
  (function_item parameters: (_) @child) @parent
  (function_item return_type: (_) @child) @parent
  (function_item (where_clause) @child) @parent
  (function_signature_item (_) @child) @parent
  (impl_item type_parameters: (_) @child) @parent
  (impl_item trait: (_) @child) @parent
  (impl_item type: (_) @child) @parent
  (impl_item (where_clause) @child) @parent
  (impl_item body: (_) @child) @parent
  (struct_item type_parameters: (_) @child) @parent
  (struct_item (where_clause) @child) @parent
  (struct_item body: (_) @child) @parent
  (trait_item type_parameters: (_) @child) @parent
  (trait_item bounds: (_) @child) @parent
  (trait_item (where_clause) @child) @parent
  (trait_item body: (_) @child) @parent
  (type_item type_parameters: (_) @child) @parent
  (type_item type: (_) @child) @parent
  (union_item type_parameters: (_) @child) @parent
  (union_item body: (_) @child) @parent

  (function_type trait: (_) @child) @parent  ;; only for Fn, FnMut, FnOnce
  (function_type parameters: (_) @child) @parent
  (function_type return_type: (_) @child) @parent
] {
  let @child.scope = @parent.inner_scope
}

;; ## Block scopes.
;;
;; Items in a block are visible throughout the block. Let-declaration bindings
;; in a block are visible starting with the next statement or expression.

;; Create the item scope.
(block) @block {
  ;; TODO: Figure out how to create these nodes conditionally. They're only
  ;; needed if the block contains items; otherwise these can just be aliases.
  ;; The reason it isn't done is I don't know how to use the query language
  ;; to distinguish blocks that have items from those that don't.
  node @block.item_scope
  edge @block.item_scope -> @block.scope

  node @block.item_values
  attr (@block.item_values) pop_symbol = "%value"
  edge @block.item_scope -> @block.item_values
  attr (@block.item_scope -> @block.item_values) precedence = 1

  node @block.item_types
  attr (@block.item_types) pop_symbol = "%type"
  edge @block.item_scope -> @block.item_types
  attr (@block.item_scope -> @block.item_types) precedence = 1
}

;; The next two rules define each child's `.scope`.
(block . (_) @first_child) @block {
  let @first_child.scope = @block.item_scope
}

(block (_) @prev . (_) @next) {
  let @next.scope = @prev.block_scope_after
}

;; The next two rules define `.block_scope_after` for each statement child.
(let_declaration pattern: (_)? @pat) @stmt {
  if some @pat {
    ;; Create the "definitions" node for let-bindings.
    node @pat.def_values
    attr (@pat.def_values) pop_symbol = "%value"
    node @stmt.block_scope_after
    edge @stmt.block_scope_after -> @pat.def_values
    attr (@stmt.block_scope_after -> @pat.def_values) precedence = 1
    edge @stmt.block_scope_after -> @stmt.scope
  } else {
    let @stmt.block_scope_after = @stmt.scope
  }
}

(block [
  ;; This is every node type that can appear in a block as a statement, except
  ;; `let_declaration`. Awkward but I don't know how else to write this.
  (empty_statement)
  (expression_statement)
  (line_comment)
  (macro_definition)
  (attribute_item)
  (inner_attribute_item)

  (associated_type)
  (enum_item)
  (extern_crate_declaration)
  (foreign_mod_item)
  (function_item)
  (function_signature_item)
  (impl_item)
  (mod_item)
  (static_item)
  (struct_item)
  (trait_item)
  (type_item)
  (union_item)
  (use_declaration)
  (const_item)
] @stmt) {
  let @stmt.block_scope_after = @stmt.scope
}

(scoped_use_list list: (_) @child) @parent {
  ;; XXX This is completely bogus but there has to be a node here
  ;; because this can contain paths.
  node @child.scope ;; bug
}


;; Default scope propagation
;;
;; Propagate scope for all syntax that does not introduce bindings.
[
  ;; Items in the file-level module scope
  (source_file (_) @child) @parent

  ;; ### Types
  ;; function_type is not listed because it can have `for_lifetimes`,
  ;; which affect the scope of its children.
  (abstract_type trait: (_) @child) @parent
  (array_type element: (_) @child) @parent
  (array_type length: (_) @child) @parent
  (bounded_type (_) @child) @parent
  (bracketed_type (_) @child) @parent
  (dynamic_type trait: (_) @child) @parent
  (generic_type type: (_) @child) @parent
  (generic_type type_arguments: (_) @child) @parent
  (pointer_type type: (_) @child) @parent
  (qualified_type type: (_) @child) @parent
  (qualified_type alias: (_) @child) @parent
  (reference_type (lifetime) @child) @parent
  (reference_type type: (_) @child) @parent
  (scoped_type_identifier path: (_) @child) @parent
  (tuple_type (_) @child) @parent
  (type_arguments (_) @child) @parent
  ;;(type_binding type_arguments: (_) @child) @parent  ;; bogus grammar
  (type_binding type: (_) @child) @parent

  ;; ### Expressions
  (arguments (_) @child) @parent
  (array_expression (_) @child) @parent
  (array_expression length: (_) @child) @parent
  (assignment_expression left: (_) @child) @parent
  (assignment_expression right: (_) @child) @parent
  (async_block (_) @child) @parent
  (await_expression (_) @child) @parent
  (base_field_initializer (_) @child) @parent
  (binary_expression left: (_) @child) @parent
  (binary_expression right: (_) @child) @parent
  (break_expression (_) @child) @parent
  (call_expression function: (_) @child) @parent
  (call_expression arguments: (_) @child) @parent
  (closure_expression parameters: (_) @child) @parent
  (closure_expression return_type: (_) @child) @parent
  (compound_assignment_expr left: (_) @child) @parent
  (compound_assignment_expr right: (_) @child) @parent
  (const_block body: (_) @child) @parent
  (continue_expression (_) @child) @parent
  (else_clause (_) @child) @parent
  (field_expression value: (_) @child) @parent
  (field_initializer_list (_) @child) @parent
  (field_initializer value: (_) @child) @parent
  (for_expression pattern: (_) @child) @parent
  (for_expression value: (_) @child) @parent
  (generic_function function: (_) @child) @parent
  (generic_function type_arguments: (_) @child) @parent
  (if_expression condition: (_) @child) @parent
  (if_expression alternative: (_) @child) @parent
  (if_expression consequence: (_) @child) @parent
  (if_let_expression pattern: (_) @child) @parent
  (if_let_expression value: (_) @child) @parent
  (if_let_expression alternative: (_) @child) @parent
  (index_expression (_) @child) @parent
  (macro_invocation macro: (_) @child) @parent
  (match_arm pattern: (_) @child) @parent
  (match_block (_) @child) @parent
  (match_expression value: (_) @child) @parent
  (match_expression body: (_) @child) @parent
  (match_pattern . (_) @child) @parent
  (parenthesized_expression (_) @child) @parent
  (range_expression (_) @child) @parent
  (reference_expression value: (_) @child) @parent
  (return_expression (_) @child) @parent
  (scoped_identifier path: (_) @child) @parent
  (shorthand_field_initializer (_) @child) @parent
  (struct_expression name: (_) @child) @parent
  (struct_expression body: (_) @child) @parent
  (try_expression (_) @child) @parent
  (tuple_expression (_) @child) @parent
  (type_cast_expression value: (_) @child) @parent
  (type_cast_expression type: (_) @child) @parent
  (unary_expression (_) @child) @parent
  (unsafe_block (_) @child) @parent
  (while_expression condition: (_) @child) @parent
  (while_let_expression pattern: (_) @child) @parent
  (while_let_expression value: (_) @child) @parent
  (yield_expression (_) @child) @parent

  ;; ### Statements
  (let_declaration pattern: (_) @child) @parent
  (let_declaration type: (_) @child) @parent
  (let_declaration value: (_) @child) @parent
  (expression_statement (_) @child) @parent

  ;; ### Patterns
  (captured_pattern (identifier) "@" (_) @child) @parent
  (captured_pattern (identifier) @child "@" (_)) @parent
  (field_pattern (_) @child) @parent
  (mut_pattern (mutable_specifier) (_) @child) @parent
  (or_pattern (_) @child) @parent
  (range_pattern (_) @child) @parent
  (ref_pattern (_) @child) @parent
  (reference_pattern (_) @child) @parent
  (slice_pattern (_) @child) @parent
  (struct_pattern (_) @child) @parent
  (tuple_pattern (_) @child) @parent
  (tuple_struct_pattern (_) @child) @parent

  ;; ### Items
  ;; Of course all items are declarations and introduce bindings into the
  ;; enclosing scope. But the real reason fn/impl/struct/enum/union/type/trait
  ;; are not here is that they can have type parameters, which affect the scope
  ;; of everything in them. (Functions, of course, can even have regular old
  ;; function parameters. Worse and worse!)
  ;;
  ;; The names of all these items, though, are in the enclosing scope (so that
  ;; you can look them up and they'll find themselves).
  ;;
  ;; Modules are not present because they reset the scope. `foreign_mod_item`
  ;; is what the Rust reference calls an `ExternBlock` or "external block".
  ;; It's not a module and it does propagate scope.
  (const_item type: (_) @child) @parent
  (const_item value: (_) @child) @parent
  (declaration_list (_) @child) @parent
  (enum_variant_list (_) @child) @parent
  (enum_variant body: (_) @child) @parent
  (enum_variant value: (_) @child) @parent
  (field_declaration type: (_) @child) @parent
  (field_declaration_list (_) @child) @parent
  (ordered_field_declaration_list (_) @child) @parent
  (foreign_mod_item body: (_) @child) @parent
  (parameter pattern: (_) @child) @parent
  (parameter type: (_) @child) @parent
  (self_parameter (lifetime) @child) @parent
  (parameters (_) @child) @parent
  (static_item type: (_) @child) @parent
  (static_item value: (_) @child) @parent
  (where_clause (where_predicate) @child) @parent
  (where_predicate left: (_) @child) @parent
  (where_predicate bounds: (_) @child) @parent
  (trait_bounds (_) @child) @parent
  (type_parameters (constrained_type_parameter bounds: (_) @child)) @parent
  (removed_trait_bound (_) @child) @parent

  ;; ### Imports
  (scoped_use_list path: (_) @child) @parent
  (use_as_clause path: (_) @child) @parent
  (use_declaration argument: (_) @child) @parent
  (use_list (_) @child) @parent
  (use_wildcard (_) @child "::" "*") @parent
] {
  let @child.scope = @parent.scope
}



;; # Marking unqualified references

;; ## Expression context
;;
;; List all contexts where an identifier is a reference to a binding in the
;; "values" namespace.
;;
;; In many contexts, it is not:
;; -   after `let x:`, or before `::`, or inside `<...>`, or after `as`,
;;     it refers to something in the type namespace
;; -   in `#[...]` it refers to an attribute, or something
;; -   before `!` it refers to a macro
;; -   between `.` and `(` it refers to a method
;; -   otherwise after `.` it refers to a field
;; -   and of course, if it's the `name:` of an item or binding,
;;     it isn't a reference at all.
;;
;; The grammar parses many of these as `identifier` syntax nodes, so it's
;; necessary to use a giant pattern to get only expression contexts.
[
  ;; ### Expressions
  (arguments [(identifier) (self)] @ident)
  (array_expression [(identifier) (self)] @ident)
  (assignment_expression left: [(identifier) (self)] @ident)
  (assignment_expression right: [(identifier) (self)] @ident)
  (await_expression [(identifier) (self)] @ident)
  (base_field_initializer [(identifier) (self)] @ident)
  (binary_expression left: [(identifier) (self)] @ident)
  (binary_expression right: [(identifier) (self)] @ident)
  (break_expression [(identifier) (self)] @ident)
  (call_expression function: [(identifier) (self)] @ident)
  (compound_assignment_expr left: [(identifier) (self)] @ident)
  (compound_assignment_expr right: [(identifier) (self)] @ident)
  (field_expression value: [(identifier) (self)] @ident)
  (field_initializer value: [(identifier) (self)] @ident)
  (for_expression value: [(identifier) (self)] @ident)
  (generic_function function: [(identifier) (self)] @ident)
  (if_expression condition: [(identifier) (self)] @ident)
  (if_let_expression value: [(identifier) (self)] @ident)
  (index_expression [(identifier) (self)] @ident)
  (match_expression value: [(identifier) (self)] @ident)
  (match_pattern condition: [(identifier) (self)] @ident)
  (parenthesized_expression [(identifier) (self)] @ident)
  (range_expression [(identifier) (self)] @ident)
  (reference_expression value: [(identifier) (self)] @ident)
  (return_expression [(identifier) (self)] @ident)
  (shorthand_field_initializer [(identifier) (self)] @ident)
  (try_expression [(identifier) (self)] @ident)
  (tuple_expression [(identifier) (self)] @ident)
  (type_cast_expression value: [(identifier) (self)] @ident)
  (unary_expression [(identifier) (self)] @ident)
  (while_expression condition: [(identifier) (self)] @ident)
  (while_let_expression value: [(identifier) (self)] @ident)
  (yield_expression [(identifier) (self)] @ident)

  ;; ### Types
  (array_type length: [(identifier) (self)] @ident)

  ;; ### Statements
  (block (_)* [(identifier) (self)] @ident)
  (expression_statement [(identifier) (self)] @ident)
  (let_declaration value: [(identifier) (self)] @ident)

  ;; ### Items
  (const_item value: [(identifier) (self)] @ident)
  (static_item value: [(identifier) (self)] @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident
  node v
  attr (v) push_symbol = "%value"
  edge @ident.use -> v
  edge v -> @ident.scope
}

;; ## Type context
;;
;; List all contexts where an identifier is a reference to a binding in the
;; "types" namespace of the current scope.
;;
;; The grammar also parses the following as `type_identifier`:
;; - names of many items, like the `X` in `struct X {}`
;; - type parameters, like the `T` in `fn f<T>() {}`
;; - the `Item` in `Iterator<Item=T>`
;; - identifiers after `::` when they refer to types
;; None of these should match here, so it's necessary to use a huge pattern to
;; get only type-expression contexts.
;;
;; Identifiers immediately before `::` in a `scoped_identifier` are also likely
;; just a bit different (I don't actually know) and are handled elsewhere for
;; now.
[
  ;; ### Types
  (abstract_type trait: (type_identifier) @ident)
  (array_type element: (type_identifier) @ident)
  (bounded_type (type_identifier) @ident)
  (dynamic_type trait: (type_identifier) @ident)
  (function_type trait: (type_identifier) @ident)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (type_identifier) @ident)
  (generic_type type: (type_identifier) @ident)
  (generic_type_with_turbofish type: (type_identifier) @ident)
  (pointer_type type: (type_identifier) @ident)
  (qualified_type type: (type_identifier) @ident)
  (qualified_type alias: (type_identifier) @ident)
  (reference_type type: (type_identifier) @ident)
  (tuple_type (type_identifier) @ident)
  (type_arguments (type_identifier) @ident) ;; ambiguous, but treat as a type for now
  (type_binding type: (type_identifier) @ident)

  ;; ### Expressions
  (type_cast_expression type: (type_identifier) @ident)
  (bracketed_type (type_identifier) @ident)
  (struct_expression name: (type_identifier) @ident)

  ;; ### Patterns
  (struct_pattern type: (type_identifier) @ident)

  ;; ### Items
  (const_item type: (type_identifier) @ident)
  (field_declaration type: (type_identifier) @ident)
  (function_item return_type: (type_identifier) @ident)
  (impl_item trait: (type_identifier) @ident)
  (impl_item type: (type_identifier) @ident)
  (ordered_field_declaration_list type: (type_identifier) @ident)
  (parameter type: (type_identifier) @ident)
  (static_item type: (type_identifier) @ident)
  (type_item type: (type_identifier) @ident)
  (trait_bounds (type_identifier) @ident)
  (where_predicate left: (type_identifier) @ident)

  ;; ### Statements
  (let_declaration type: (type_identifier) @ident)
] {
  node @ident.use
  attr (@ident.use) node_reference = @ident

  let t = (node)
  attr (t) push_symbol = "%type"
  edge @ident.use -> t
  edge t -> @ident.scope
}

;; The type-tag in a tuple_struct_pattern is a gruesome special case in rustc.
;; It looks in both namespaces, preferring inner scopes to outer scopes, and
;; when it finds both a value and a type in the same lexical scope, picking the
;; type.
;;
;; Our graph can't implement this exactly, but we can get pretty close.
(tuple_struct_pattern type: (identifier) @ident) {
  node @ident.use
  attr (@ident.use) node_reference = @ident

  ;; Optional "%type" node!
  let t = (node)
  attr (t) push_symbol = "%type"
  edge @ident.use -> t
  attr (@ident.use -> t) precedence = 1
  edge t -> @ident.scope
  edge @ident.use -> @ident.scope
}



; # Uses of `self`, `super`, and `crate`

[
  (scoped_identifier path: [(self) (super)] @keyword)
  (scoped_type_identifier path: [(self) (super)] @keyword)
  (scoped_use_list path: [(self) (super)] @keyword)
  (use_as_clause path: [(self) (super)] @keyword)
  (use_list [(self) (super)] @keyword)
  (use_wildcard . [(self) (super)] @keyword)
  (visibility_modifier [(self) (super)] @keyword)
  ;; bogus if it happens, but accepted by the parser:
  (range_pattern [(self) (super)] @keyword)
] {
  node @keyword.use
  attr (@keyword.use) node_reference = @keyword

  let t = (node)
  attr (t) push_symbol = "%type"
  edge @keyword.use -> t
  edge t -> @keyword.scope
}

[
  (scoped_identifier path: (crate) @keyword)
  (scoped_type_identifier path: (crate) @keyword)
  (scoped_use_list path: (crate) @keyword)
  (use_as_clause path: (crate) @keyword)
  (use_list (crate) @keyword)
  (use_wildcard . (crate) @keyword)
  (visibility_modifier (crate) @keyword)
  ;; bogus if it happens, but accepted by the parser:
  (range_pattern (crate) @keyword)
] {
  ;; All uses of `crate` are threaded through the root node,
  ;; so they can cross file boundaries.
  node @keyword.use
  attr (@keyword.use) type = "push_symbol", symbol = "%crate", is_reference, source_node = @keyword
  edge @keyword.use -> ROOT_NODE
}


; # Item definitions

[
  (source_file) @root
  (declaration_list) @root
] {
  node @root.def_types
  attr (@root.def_types) pop_symbol = "%type"
  edge @root.scope -> @root.def_types
  attr (@root.scope -> @root.def_types) precedence = 1

  node @root.def_values
  attr (@root.def_values) pop_symbol = "%value"
  edge @root.scope -> @root.def_values
  attr (@root.scope -> @root.def_values) precedence = 1
}

[
  (source_file (_) @child) @parent
  (declaration_list (_) @child) @parent
] {
  let @child.item_def_values = @parent.def_values
  let @child.item_def_types = @parent.def_types
}

;; Tell block-scoped items which node they should hang definitions on.
;;
;; (The two scoped variables `.item_def_values` and `item_values` look like
;; they ought to have the same name, but that wouldn't work. The selector here
;; does not select only item children but all children; one of those children
;; might be another block, and then there'd be a conflict.)
(block (_) @child) @parent {
  let @child.item_def_values = @parent.item_values
  let @child.item_def_types = @parent.item_types
}

[
  (const_item name: (_) @name)
  (enum_item name: (_) @name)
  (function_item name: (_) @name)
  (mod_item name: (_) @name)
  (static_item name: (_) @name)
  (struct_item name: (_) @name)
  (trait_item name: (_) @name)
  (type_item name: (_) @name)
  (union_item name: (_) @name)
] @item {
  node @item.def
  attr (@item.def) node_definition = @name
}

;; Bind items in the value namespace. Note: We bind tuple structs in both
;; namespaces. Same for unit structs (the next rule below). Structs with named
;; fields are bound only in the type namespace.
[
  (const_item)
  (static_item)
  (struct_item body: (ordered_field_declaration_list))
  (function_item)
] @item {
  edge @item.item_def_values -> @item.def
}

(struct_item body: (_)? @body) @item {
  if none @body {
    edge @item.item_def_values -> @item.def
  }
}

;; Bind items in the type namespace.
[
  (enum_item)
  (mod_item)
  (struct_item)
  (trait_item)
  (type_item)
  (union_item)
] @item {
  edge @item.item_def_types -> @item.def
}



;; # Function and closure parameters

;; This is awkward because `closure_parameters` have two different structures
;; only one of which (`parameter`) can be easily distinguished with a query.
;;
;; TODO - See if this can be made any tidier.

[(parameters) (closure_parameters)] @parameters {
  node @parameters.def_values
  attr (@parameters.def_values) pop_symbol = "%value"
}

[
  (parameters (parameter) @child)
  (parameters (self_parameter) @child)
  (closure_parameters (_) @child)
] @parameters {
  let @child.def_values = @parameters.def_values
}

(parameter pattern: (_) @pat) @param {
  let @pat.def_values = @param.def_values
}

(self_parameter (self) @self) @param {
  node @self.def
  attr (@self.def) node_definition = @self
  edge @param.def_values -> @self.def
}

(closure_expression) @closure {
  ;; Used below. Just an alias, because closures don't have type parameters.
  let @closure.inner_scope = @closure.scope
}

[
  (closure_expression parameters: (_) @parameters body: (_) @body)
  (function_item parameters: (_) @parameters body: (_) @body)
] @parent {
  node @body.scope
  edge @body.scope -> @parameters.def_values
  attr (@body.scope -> @parameters.def_values) precedence = 1
  edge @body.scope -> @parent.inner_scope
}


;; # Binding the file module
;;
;; In which we help folks coming in from the root node to tell if the path
;; they're looking for is really located in this file.
(source_file) @root {
  node crate_node
  attr (crate_node) source_node = @root, pop_symbol = "%crate", is_definition
  edge ROOT_NODE -> crate_node

  var new_node = #null
  var current_node = (node)

  ;; Doing this properly will involve understanding Cargo package layout in
  ;; detail :-P
  scan FILE_PATH {
    "([^/]+\.rs|src/main\.rs|src/lib\.rs)$" {
      ;; Treat this as a standalone binary in a single file.
      ;; Hook up `crate` and `self` for file-level modules.

      ;; Bind `crate` to the definition node representing the entire crate.
      let @root.def = crate_node
      edge crate_node -> @root.def_types
      edge crate_node -> @root.def_values

      ;; Bind `self` to a node with identical out-edges. (Can't use the same
      ;; node because TSG doesn't really support aliases: only nodes with
      ;; type = "pop_symbol" can be definitions.)
      node self
      attr (self) source_node = @root, pop_symbol = "self", is_definition
      edge @root.def_types -> self
      edge self -> @root.def_types
      edge self -> @root.def_values
    }

    "^src/([^/]+)\.rs$" {
      node crate_def_types
      attr (crate_def_types) pop_symbol = "%type"
      edge crate_node -> crate_def_types
      attr (crate_node -> crate_def_types) precedence = 1

      node mod_def
      attr (mod_def) source_node = @root, pop_symbol = $1, is_definition
      edge crate_def_types -> mod_def

      ;; The rest of this is copied from the code that handles a mod_item.
      edge mod_def -> @root.def_values
      edge mod_def -> @root.def_types

      ;; Define `self` as a node effectively identical to `mod_def`. (Can't use
      ;; the same node because TSG doesn't support aliases.)
      node self
      attr (self) source_node = @root, pop_symbol = "self", is_definition
      edge @root.def_types -> self
      edge self -> @root.def_values
      edge self -> @root.def_types

      ;; Bind `super` in the implicit module as an alias for `crate`.
      node super
      attr (super) pop_symbol = "super"
      node super_1
      attr (super_1) push_symbol = "self"
      edge @root.def_types -> super
      edge super -> super_1
      edge super_1 -> @root.def_types
    }
  }
}

;; # Qualified access
;; In which we set up paths from definitions to their members, `self`, `super`,
;; and `crate`.

;; Install a path from a module definition to the types defined inside it.
;; Also hook up `self`, `super`, and `crate` for declared modules.
(mod_item name: (identifier) @name body: (declaration_list) @body) @mod {
  edge @mod.def -> @body.def_values
  edge @mod.def -> @body.def_types

  ;; Define `self` as a node effectively identical to `@mod.def`. (Can't use
  ;; the same node because TSG doesn't support aliases.)
  node self
  attr (self) source_node = @name, pop_symbol = "self", is_definition
  edge @body.def_types -> self
  edge self -> @body.def_values
  edge self -> @body.def_types

  ;; Bind `super` in a declared module as an alias for `self` in the enclosing
  ;; module.
  node super
  attr (super) pop_symbol = "super"
  node super_1
  attr (super_1) push_symbol = "self"
  node super_2
  attr (super_2) push_symbol = "%type"
  edge @body.def_types -> super
  edge super -> super_1
  edge super_1 -> super_2
  edge super_2 -> @mod.scope
}

;; Trait members are not in scope for unqualified access, but they can be
;; accessed by paths via the trait.
(trait_item body: (declaration_list) @decls) @trait {
  edge @trait.def -> @decls.def_values
  edge @trait.def -> @decls.def_types
}

;; Install a path from a struct definition to its fields.
(struct_item body: (field_declaration_list) @fields) @struct {
  edge @struct.def -> @fields.fields
}

;; Note this is used by struct-like enum variants too.
(field_declaration_list) @fields {
  node @fields.fields
  attr (@fields.fields) pop_symbol = "%field"
}

(field_declaration_list (field_declaration name: (_) @field)) @fields {
  node @field.def
  attr (@field.def) node_definition = @field
  edge @fields.fields -> @field.def
}

;; Install paths from an enum to its variants.
(enum_item name: (type_identifier) @name ) @enum {
  node @enum.variants_types
  node t
  attr (t) pop_symbol = "%type"
  edge @enum.def -> t
  edge t -> @enum.variants_types

  node @enum.variants_values
  node v
  attr (v) pop_symbol = "%value"
  edge @enum.def -> v
  edge v -> @enum.variants_values
}

(enum_item
  body: (enum_variant_list
    (enum_variant
      name: (identifier) @name
      (field_declaration_list)? @fields
    ) @variant
  )
) @enum {
  node @variant.def
  attr (@variant.def) node_definition = @name
  if some @fields {
    edge @enum.variants_types -> @variant.def
    edge @variant.def -> @fields.fields
  }
  edge @enum.variants_values -> @variant.def
}


;; # Paths
;;
;; What tree-sitter-rust calls a `scoped_identifier` is what the rest of the
;; Rust world calls a path.

;; The `path:` of a `scoped_identifier` or `scoped_type_identifier` is one of
;; - `self` / `super` / `crate`
;; - identifier
;; - scoped_identifier
;; - bracketed_type
;; - generic_type
;; So far we do not handle generic_type at all.

;; Note: This is a complete copy of the huge list under "Marking unqualified
;; references". Obviously the duplication is very bad. I don't know how else to
;; get this effect.

[
  ;; ### Expressions
  (arguments (_) @here)
  (array_expression (_) @here)
  (assignment_expression left: (_) @here)
  (assignment_expression right: (_) @here)
  (await_expression (_) @here)
  (base_field_initializer (_) @here)
  (binary_expression left: (_) @here)
  (binary_expression right: (_) @here)
  (break_expression (_) @here)
  (call_expression function: (_) @here)
  (compound_assignment_expr left: (_) @here)
  (compound_assignment_expr right: (_) @here)
  (field_expression value: (_) @here)
  (field_initializer value: (_) @here)
  (for_expression value: (_) @here)
  (generic_function function: (_) @here)
  (if_expression condition: (_) @here)
  (if_let_expression value: (_) @here)
  (index_expression (_) @here)
  (match_expression value: (_) @here)
  (match_pattern condition: (_) @here)
  (parenthesized_expression (_) @here)
  (range_expression (_) @here)
  (reference_expression value: (_) @here)
  (return_expression (_) @here)
  (shorthand_field_initializer (_) @here)
  (try_expression (_) @here)
  (tuple_expression (_) @here)
  (type_cast_expression value: (_) @here)
  (unary_expression (_) @here)
  (while_expression condition: (_) @here)
  (while_let_expression value: (_) @here)
  (yield_expression (_) @here)

  ;; ### Types
  (array_type length: (_) @here)

  ;; ### Statements
  (block (_)* (_) @here)
  (expression_statement (_) @here)
  (let_declaration value: (_) @here)

  ;; ### Items
  (const_item value: (_) @here)
  (static_item value: (_) @here)
] {
  let @here.context = "%value"
}

;; Note: This is a complete copy of the second huge list under "Marking
;; unqualified references".
[
  ;; ### Types
  (abstract_type trait: (_) @here)
  (array_type element: (_) @here)
  (bounded_type (_) @here)
  (dynamic_type trait: (_) @here)
  (function_type trait: (_) @here)  ;; only for Fn, FnMut, FnOnce
  (function_type return_type: (_) @here)
  (generic_type type: (_) @here)
  (generic_type_with_turbofish type: (_) @here)
  (pointer_type type: (_) @here)
  (qualified_type type: (_) @here)
  (qualified_type alias: (_) @here)
  (reference_type type: (_) @here)
  (scoped_type_identifier path: (_) @here)
  (tuple_type (_) @here)
  (type_binding type: (_) @here)

  ;; ### Expressions
  (type_cast_expression type: (_) @here)
  (bracketed_type (_) @here)
  (struct_expression name: (_) @here)
  (scoped_identifier path: (_) @here)

  ;; ### Patterns
  (struct_pattern type: (_) @here)

  ;; ### Items
  (const_item type: (_) @here)
  (field_declaration type: (_) @here)
  (function_item return_type: (_) @here)
  (impl_item trait: (_) @here)
  (impl_item type: (_) @here)
  (ordered_field_declaration_list type: (_) @here)
  (parameter type: (_) @here)
  (static_item type: (_) @here)
  (trait_bounds (_) @here)
  (type_item type: (_) @here)
  (where_predicate left: (_) @here)

  ;; ### Statements
  (let_declaration type: (_) @here)
] {
  let @here.context = "%type"
}

;; Ambiguous contexts
(type_arguments (_) @here) {
  ;; type or value depending on the generic, I think
  let @here.context = "%type" ;; bug
}

(tuple_struct_pattern type: (_) @here) {
  ;; type or value, whichever comes first
  let @here.context = "%value" ;; bug
}

;; Pattern context
[
  (for_expression pattern: (_) @here)
  (if_let_expression pattern: (_) @here)
  (while_let_expression pattern: (_) @here)
  (let_declaration pattern: (_) @here)
  (parameter pattern: (_) @here)
  (closure_parameters (_) @here)
  (match_pattern . (_) @here)
  (tuple_pattern (_) @here)
  (tuple_struct_pattern type: (_) (_) @here)
  (slice_pattern (_) @here)
  (field_pattern name: (shorthand_field_identifier) @here)
  (field_pattern pattern: (_) @here)
  (mut_pattern (mutable_specifier) (_) @here)
  (ref_pattern (_) @here)
  (captured_pattern (_) @here "@" (_))
  (reference_pattern "&" (mutable_specifier)? (_) @here)
  (or_pattern (_) @here)
] {
  let @here.context = "%pattern"
}

;; Macro context
(macro_invocation macro: (_) @here) {
  let @here.context = "%macro"
}

;; Use-path context
[
  (scoped_use_list path: (_) @here)
  (use_as_clause path: (_) @here)
  (use_declaration argument: (_) @here)
  (use_list (_) @here)
  (use_wildcard (_) @here "::" "*")
] {
  ;; BUG - This causes the last segment of paths not to resolve in all these
  ;; contexts. Need both.
  let @here.context = "%other"
}

[
  (scoped_identifier path: (_)? @parent name: (identifier) @name) @path
  (scoped_type_identifier path: (_)? @parent name: [(type_identifier) @type] @name) @path
] {
  node @name.use
  attr (@name.use) node_reference = @name
  let @path.use = @name.use

  node s
  attr (s) push_symbol = (replace @path.context "%pattern" "%value")

  edge @name.use -> s
  if some @parent {
    edge s -> @parent.use
  } else {
    ;; `::foo` syntax. This is a crate name. TODO - connect s to the extern crates.
  }
}

[
  (scoped_identifier path: (identifier) @name)
  (scoped_type_identifier path: (identifier) @name)
] {
  ;; For now, just treat this as a type_identifier.
  node @name.use
  attr (@name.use) node_reference = @name

  let t = (node)
  attr (t) push_symbol = "%type"
  edge @name.use -> t
  edge t -> @name.scope
}

(bracketed_type (_) @child) @parent {
  let @parent.use = @child.use
}

(qualified_type alias: (_) @trait) @parent {
  let @parent.use = @trait.use
}

(scoped_identifier path: (generic_type) @parent) {
  ;; Dummy node to avoid "undefined scoped variable". Not hooked up yet.
  node @parent.use
}



;; # Fields
;; Link fields in struct expressions and patterns to their definitions.

[
  (struct_expression
    body: (field_initializer_list
      (field_initializer name: (field_identifier) @field_name)
    )
  )
  (struct_pattern (field_pattern name: (_) @field_name))
] {
  node @field_name.use
  attr (@field_name.use) node_reference = @field_name
}

(struct_expression
  name: [(type_identifier) (scoped_type_identifier)] @ty
  body: (field_initializer_list [
    (field_initializer name: (field_identifier) @field_name)
    (shorthand_field_initializer (identifier) @field_name)
  ])
) {
  node push_fields
  attr (push_fields) push_symbol = "%field"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}

(struct_pattern
  type: [(type_identifier) (scoped_type_identifier)] @ty
  [
    (field_pattern name: (_) @field_name)
    (shorthand_field_identifier) @field_name
  ]
) {
  node push_fields
  attr (push_fields) push_symbol = "%field"
  edge @field_name.use -> push_fields
  edge push_fields -> @ty.use
}



;; # Lifetimes
;; See also `(type_parameters (lifetime) @lifetime) @params` above.

;; Uses of lifetimes.
[
  (where_predicate left: (lifetime) @lifetime)
  (trait_bounds (lifetime) @lifetime)
  (self_parameter (lifetime) @lifetime)
  (bounded_type (lifetime) @lifetime)
  (type_arguments (lifetime) @lifetime)
  (reference_type (lifetime) @lifetime)
] {
  node @lifetime.use
  attr (@lifetime.use) node_reference = @lifetime
  node t
  attr (t) push_symbol = "%type"
  edge @lifetime.use -> t
  edge t -> @lifetime.scope
}



;; # Loop labels
;; These look like lifetimes but inhabit a separate namespace.

;; Uses of loop labels.
[
  (break_expression (loop_label) @label)
  (continue_expression (loop_label) @label)
] @expr {
  node @label.use
  attr (@label.use) node_reference = @label
  node t
  attr (t) push_symbol = "%loop"
  edge @label.use -> t
  edge t -> @expr.scope
}



;; # Imports
(use_declaration
  (scoped_identifier path: (_) @parent name: (identifier) @name)
) @import {
  ;; When looking for a name in the type namespace, and finding an import, go
  ;; find whatever `@parent` points to, then look up the name in that thing's
  ;; type namespace.
  node type_relay
  attr (type_relay) type = "pop_symbol", node_symbol = @name
  node type_relay1
  attr (type_relay1) type = "push_symbol", node_symbol = @name
  node type_relay2
  attr (type_relay2) push_symbol = "%type"
  edge @import.item_def_types -> type_relay
  edge type_relay -> type_relay1
  edge type_relay1 -> type_relay2
  edge type_relay2 -> @parent.use

  ;; Same deal for the value namespace.
  node value_relay
  attr (value_relay) type = "pop_symbol", node_symbol = @name
  node value_relay1
  attr (value_relay1) type = "push_symbol", node_symbol = @name
  node value_relay2
  attr (value_relay2) push_symbol = "%value"
  edge @import.item_def_values -> value_relay
  edge value_relay -> value_relay1
  edge value_relay1 -> value_relay2
  edge value_relay2 -> @parent.use
}
